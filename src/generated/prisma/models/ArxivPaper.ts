
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ArxivPaper` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model ArxivPaper
 * 
 */
export type ArxivPaperModel = runtime.Types.Result.DefaultSelection<Prisma.$ArxivPaperPayload>

export type AggregateArxivPaper = {
  _count: ArxivPaperCountAggregateOutputType | null
  _min: ArxivPaperMinAggregateOutputType | null
  _max: ArxivPaperMaxAggregateOutputType | null
}

export type ArxivPaperMinAggregateOutputType = {
  id: string | null
  arxivId: string | null
  arxivUrl: string | null
  title: string | null
  abstract: string | null
  publishedDate: string | null
  primaryCategory: string | null
  license: string | null
  updatedAtArxiv: string | null
  comment: string | null
  journalRef: string | null
  doi: string | null
  status: string | null
  processedAt: Date | null
  referencesFetched: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type ArxivPaperMaxAggregateOutputType = {
  id: string | null
  arxivId: string | null
  arxivUrl: string | null
  title: string | null
  abstract: string | null
  publishedDate: string | null
  primaryCategory: string | null
  license: string | null
  updatedAtArxiv: string | null
  comment: string | null
  journalRef: string | null
  doi: string | null
  status: string | null
  processedAt: Date | null
  referencesFetched: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type ArxivPaperCountAggregateOutputType = {
  id: number
  arxivId: number
  arxivUrl: number
  title: number
  abstract: number
  publishedDate: number
  primaryCategory: number
  license: number
  updatedAtArxiv: number
  comment: number
  journalRef: number
  doi: number
  status: number
  processedAt: number
  referencesFetched: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type ArxivPaperMinAggregateInputType = {
  id?: true
  arxivId?: true
  arxivUrl?: true
  title?: true
  abstract?: true
  publishedDate?: true
  primaryCategory?: true
  license?: true
  updatedAtArxiv?: true
  comment?: true
  journalRef?: true
  doi?: true
  status?: true
  processedAt?: true
  referencesFetched?: true
  createdAt?: true
  updatedAt?: true
}

export type ArxivPaperMaxAggregateInputType = {
  id?: true
  arxivId?: true
  arxivUrl?: true
  title?: true
  abstract?: true
  publishedDate?: true
  primaryCategory?: true
  license?: true
  updatedAtArxiv?: true
  comment?: true
  journalRef?: true
  doi?: true
  status?: true
  processedAt?: true
  referencesFetched?: true
  createdAt?: true
  updatedAt?: true
}

export type ArxivPaperCountAggregateInputType = {
  id?: true
  arxivId?: true
  arxivUrl?: true
  title?: true
  abstract?: true
  publishedDate?: true
  primaryCategory?: true
  license?: true
  updatedAtArxiv?: true
  comment?: true
  journalRef?: true
  doi?: true
  status?: true
  processedAt?: true
  referencesFetched?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type ArxivPaperAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ArxivPaper to aggregate.
   */
  where?: Prisma.ArxivPaperWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ArxivPapers to fetch.
   */
  orderBy?: Prisma.ArxivPaperOrderByWithRelationInput | Prisma.ArxivPaperOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ArxivPaperWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ArxivPapers from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ArxivPapers.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ArxivPapers
  **/
  _count?: true | ArxivPaperCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ArxivPaperMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ArxivPaperMaxAggregateInputType
}

export type GetArxivPaperAggregateType<T extends ArxivPaperAggregateArgs> = {
      [P in keyof T & keyof AggregateArxivPaper]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateArxivPaper[P]>
    : Prisma.GetScalarType<T[P], AggregateArxivPaper[P]>
}




export type ArxivPaperGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ArxivPaperWhereInput
  orderBy?: Prisma.ArxivPaperOrderByWithAggregationInput | Prisma.ArxivPaperOrderByWithAggregationInput[]
  by: Prisma.ArxivPaperScalarFieldEnum[] | Prisma.ArxivPaperScalarFieldEnum
  having?: Prisma.ArxivPaperScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ArxivPaperCountAggregateInputType | true
  _min?: ArxivPaperMinAggregateInputType
  _max?: ArxivPaperMaxAggregateInputType
}

export type ArxivPaperGroupByOutputType = {
  id: string
  arxivId: string
  arxivUrl: string
  title: string | null
  abstract: string | null
  publishedDate: string | null
  primaryCategory: string | null
  license: string | null
  updatedAtArxiv: string | null
  comment: string | null
  journalRef: string | null
  doi: string | null
  status: string
  processedAt: Date | null
  referencesFetched: boolean
  createdAt: Date
  updatedAt: Date
  _count: ArxivPaperCountAggregateOutputType | null
  _min: ArxivPaperMinAggregateOutputType | null
  _max: ArxivPaperMaxAggregateOutputType | null
}

type GetArxivPaperGroupByPayload<T extends ArxivPaperGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ArxivPaperGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ArxivPaperGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ArxivPaperGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ArxivPaperGroupByOutputType[P]>
      }
    >
  >



export type ArxivPaperWhereInput = {
  AND?: Prisma.ArxivPaperWhereInput | Prisma.ArxivPaperWhereInput[]
  OR?: Prisma.ArxivPaperWhereInput[]
  NOT?: Prisma.ArxivPaperWhereInput | Prisma.ArxivPaperWhereInput[]
  id?: Prisma.StringFilter<"ArxivPaper"> | string
  arxivId?: Prisma.StringFilter<"ArxivPaper"> | string
  arxivUrl?: Prisma.StringFilter<"ArxivPaper"> | string
  title?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  abstract?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  publishedDate?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  primaryCategory?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  license?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  updatedAtArxiv?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  comment?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  journalRef?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  doi?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  status?: Prisma.StringFilter<"ArxivPaper"> | string
  processedAt?: Prisma.DateTimeNullableFilter<"ArxivPaper"> | Date | string | null
  referencesFetched?: Prisma.BoolFilter<"ArxivPaper"> | boolean
  createdAt?: Prisma.DateTimeFilter<"ArxivPaper"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"ArxivPaper"> | Date | string
  authors?: Prisma.ArxivAuthorNameListRelationFilter
  categories?: Prisma.ArxivCategoryListRelationFilter
  references?: Prisma.ReferenceListRelationFilter
  citedBy?: Prisma.ReferenceListRelationFilter
  semanticScholarPaper?: Prisma.XOR<Prisma.SemanticScholarPaperNullableScalarRelationFilter, Prisma.SemanticScholarPaperWhereInput> | null
}

export type ArxivPaperOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  arxivId?: Prisma.SortOrder
  arxivUrl?: Prisma.SortOrder
  title?: Prisma.SortOrderInput | Prisma.SortOrder
  abstract?: Prisma.SortOrderInput | Prisma.SortOrder
  publishedDate?: Prisma.SortOrderInput | Prisma.SortOrder
  primaryCategory?: Prisma.SortOrderInput | Prisma.SortOrder
  license?: Prisma.SortOrderInput | Prisma.SortOrder
  updatedAtArxiv?: Prisma.SortOrderInput | Prisma.SortOrder
  comment?: Prisma.SortOrderInput | Prisma.SortOrder
  journalRef?: Prisma.SortOrderInput | Prisma.SortOrder
  doi?: Prisma.SortOrderInput | Prisma.SortOrder
  status?: Prisma.SortOrder
  processedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  referencesFetched?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  authors?: Prisma.ArxivAuthorNameOrderByRelationAggregateInput
  categories?: Prisma.ArxivCategoryOrderByRelationAggregateInput
  references?: Prisma.ReferenceOrderByRelationAggregateInput
  citedBy?: Prisma.ReferenceOrderByRelationAggregateInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperOrderByWithRelationInput
}

export type ArxivPaperWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  arxivId?: string
  AND?: Prisma.ArxivPaperWhereInput | Prisma.ArxivPaperWhereInput[]
  OR?: Prisma.ArxivPaperWhereInput[]
  NOT?: Prisma.ArxivPaperWhereInput | Prisma.ArxivPaperWhereInput[]
  arxivUrl?: Prisma.StringFilter<"ArxivPaper"> | string
  title?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  abstract?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  publishedDate?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  primaryCategory?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  license?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  updatedAtArxiv?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  comment?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  journalRef?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  doi?: Prisma.StringNullableFilter<"ArxivPaper"> | string | null
  status?: Prisma.StringFilter<"ArxivPaper"> | string
  processedAt?: Prisma.DateTimeNullableFilter<"ArxivPaper"> | Date | string | null
  referencesFetched?: Prisma.BoolFilter<"ArxivPaper"> | boolean
  createdAt?: Prisma.DateTimeFilter<"ArxivPaper"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"ArxivPaper"> | Date | string
  authors?: Prisma.ArxivAuthorNameListRelationFilter
  categories?: Prisma.ArxivCategoryListRelationFilter
  references?: Prisma.ReferenceListRelationFilter
  citedBy?: Prisma.ReferenceListRelationFilter
  semanticScholarPaper?: Prisma.XOR<Prisma.SemanticScholarPaperNullableScalarRelationFilter, Prisma.SemanticScholarPaperWhereInput> | null
}, "id" | "arxivId">

export type ArxivPaperOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  arxivId?: Prisma.SortOrder
  arxivUrl?: Prisma.SortOrder
  title?: Prisma.SortOrderInput | Prisma.SortOrder
  abstract?: Prisma.SortOrderInput | Prisma.SortOrder
  publishedDate?: Prisma.SortOrderInput | Prisma.SortOrder
  primaryCategory?: Prisma.SortOrderInput | Prisma.SortOrder
  license?: Prisma.SortOrderInput | Prisma.SortOrder
  updatedAtArxiv?: Prisma.SortOrderInput | Prisma.SortOrder
  comment?: Prisma.SortOrderInput | Prisma.SortOrder
  journalRef?: Prisma.SortOrderInput | Prisma.SortOrder
  doi?: Prisma.SortOrderInput | Prisma.SortOrder
  status?: Prisma.SortOrder
  processedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  referencesFetched?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.ArxivPaperCountOrderByAggregateInput
  _max?: Prisma.ArxivPaperMaxOrderByAggregateInput
  _min?: Prisma.ArxivPaperMinOrderByAggregateInput
}

export type ArxivPaperScalarWhereWithAggregatesInput = {
  AND?: Prisma.ArxivPaperScalarWhereWithAggregatesInput | Prisma.ArxivPaperScalarWhereWithAggregatesInput[]
  OR?: Prisma.ArxivPaperScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ArxivPaperScalarWhereWithAggregatesInput | Prisma.ArxivPaperScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"ArxivPaper"> | string
  arxivId?: Prisma.StringWithAggregatesFilter<"ArxivPaper"> | string
  arxivUrl?: Prisma.StringWithAggregatesFilter<"ArxivPaper"> | string
  title?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  abstract?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  publishedDate?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  primaryCategory?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  license?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  updatedAtArxiv?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  comment?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  journalRef?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  doi?: Prisma.StringNullableWithAggregatesFilter<"ArxivPaper"> | string | null
  status?: Prisma.StringWithAggregatesFilter<"ArxivPaper"> | string
  processedAt?: Prisma.DateTimeNullableWithAggregatesFilter<"ArxivPaper"> | Date | string | null
  referencesFetched?: Prisma.BoolWithAggregatesFilter<"ArxivPaper"> | boolean
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"ArxivPaper"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"ArxivPaper"> | Date | string
}

export type ArxivPaperCreateInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameCreateNestedManyWithoutArxivPaperInput
  categories?: Prisma.ArxivCategoryCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceCreateNestedManyWithoutPaperInput
  citedBy?: Prisma.ReferenceCreateNestedManyWithoutReferenceInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperUncheckedCreateInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedCreateNestedManyWithoutArxivPaperInput
  categories?: Prisma.ArxivCategoryUncheckedCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceUncheckedCreateNestedManyWithoutPaperInput
  citedBy?: Prisma.ReferenceUncheckedCreateNestedManyWithoutReferenceInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUpdateManyWithoutArxivPaperNestedInput
  categories?: Prisma.ArxivCategoryUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUpdateManyWithoutPaperNestedInput
  citedBy?: Prisma.ReferenceUpdateManyWithoutReferenceNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedUpdateManyWithoutArxivPaperNestedInput
  categories?: Prisma.ArxivCategoryUncheckedUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUncheckedUpdateManyWithoutPaperNestedInput
  citedBy?: Prisma.ReferenceUncheckedUpdateManyWithoutReferenceNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperCreateManyInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type ArxivPaperUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ArxivPaperUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ArxivPaperCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  arxivId?: Prisma.SortOrder
  arxivUrl?: Prisma.SortOrder
  title?: Prisma.SortOrder
  abstract?: Prisma.SortOrder
  publishedDate?: Prisma.SortOrder
  primaryCategory?: Prisma.SortOrder
  license?: Prisma.SortOrder
  updatedAtArxiv?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  journalRef?: Prisma.SortOrder
  doi?: Prisma.SortOrder
  status?: Prisma.SortOrder
  processedAt?: Prisma.SortOrder
  referencesFetched?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ArxivPaperMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  arxivId?: Prisma.SortOrder
  arxivUrl?: Prisma.SortOrder
  title?: Prisma.SortOrder
  abstract?: Prisma.SortOrder
  publishedDate?: Prisma.SortOrder
  primaryCategory?: Prisma.SortOrder
  license?: Prisma.SortOrder
  updatedAtArxiv?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  journalRef?: Prisma.SortOrder
  doi?: Prisma.SortOrder
  status?: Prisma.SortOrder
  processedAt?: Prisma.SortOrder
  referencesFetched?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ArxivPaperMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  arxivId?: Prisma.SortOrder
  arxivUrl?: Prisma.SortOrder
  title?: Prisma.SortOrder
  abstract?: Prisma.SortOrder
  publishedDate?: Prisma.SortOrder
  primaryCategory?: Prisma.SortOrder
  license?: Prisma.SortOrder
  updatedAtArxiv?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  journalRef?: Prisma.SortOrder
  doi?: Prisma.SortOrder
  status?: Prisma.SortOrder
  processedAt?: Prisma.SortOrder
  referencesFetched?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type ArxivPaperScalarRelationFilter = {
  is?: Prisma.ArxivPaperWhereInput
  isNot?: Prisma.ArxivPaperWhereInput
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string
}

export type ArxivPaperCreateNestedOneWithoutAuthorsInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutAuthorsInput, Prisma.ArxivPaperUncheckedCreateWithoutAuthorsInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutAuthorsInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
}

export type ArxivPaperUpdateOneRequiredWithoutAuthorsNestedInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutAuthorsInput, Prisma.ArxivPaperUncheckedCreateWithoutAuthorsInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutAuthorsInput
  upsert?: Prisma.ArxivPaperUpsertWithoutAuthorsInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.ArxivPaperUpdateToOneWithWhereWithoutAuthorsInput, Prisma.ArxivPaperUpdateWithoutAuthorsInput>, Prisma.ArxivPaperUncheckedUpdateWithoutAuthorsInput>
}

export type ArxivPaperCreateNestedOneWithoutCategoriesInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutCategoriesInput, Prisma.ArxivPaperUncheckedCreateWithoutCategoriesInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutCategoriesInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
}

export type ArxivPaperUpdateOneRequiredWithoutCategoriesNestedInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutCategoriesInput, Prisma.ArxivPaperUncheckedCreateWithoutCategoriesInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutCategoriesInput
  upsert?: Prisma.ArxivPaperUpsertWithoutCategoriesInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.ArxivPaperUpdateToOneWithWhereWithoutCategoriesInput, Prisma.ArxivPaperUpdateWithoutCategoriesInput>, Prisma.ArxivPaperUncheckedUpdateWithoutCategoriesInput>
}

export type ArxivPaperCreateNestedOneWithoutReferencesInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutReferencesInput, Prisma.ArxivPaperUncheckedCreateWithoutReferencesInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutReferencesInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
}

export type ArxivPaperCreateNestedOneWithoutCitedByInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutCitedByInput, Prisma.ArxivPaperUncheckedCreateWithoutCitedByInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutCitedByInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
}

export type ArxivPaperUpdateOneRequiredWithoutReferencesNestedInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutReferencesInput, Prisma.ArxivPaperUncheckedCreateWithoutReferencesInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutReferencesInput
  upsert?: Prisma.ArxivPaperUpsertWithoutReferencesInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.ArxivPaperUpdateToOneWithWhereWithoutReferencesInput, Prisma.ArxivPaperUpdateWithoutReferencesInput>, Prisma.ArxivPaperUncheckedUpdateWithoutReferencesInput>
}

export type ArxivPaperUpdateOneRequiredWithoutCitedByNestedInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutCitedByInput, Prisma.ArxivPaperUncheckedCreateWithoutCitedByInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutCitedByInput
  upsert?: Prisma.ArxivPaperUpsertWithoutCitedByInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.ArxivPaperUpdateToOneWithWhereWithoutCitedByInput, Prisma.ArxivPaperUpdateWithoutCitedByInput>, Prisma.ArxivPaperUncheckedUpdateWithoutCitedByInput>
}

export type ArxivPaperCreateNestedOneWithoutSemanticScholarPaperInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutSemanticScholarPaperInput, Prisma.ArxivPaperUncheckedCreateWithoutSemanticScholarPaperInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutSemanticScholarPaperInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
}

export type ArxivPaperUpdateOneRequiredWithoutSemanticScholarPaperNestedInput = {
  create?: Prisma.XOR<Prisma.ArxivPaperCreateWithoutSemanticScholarPaperInput, Prisma.ArxivPaperUncheckedCreateWithoutSemanticScholarPaperInput>
  connectOrCreate?: Prisma.ArxivPaperCreateOrConnectWithoutSemanticScholarPaperInput
  upsert?: Prisma.ArxivPaperUpsertWithoutSemanticScholarPaperInput
  connect?: Prisma.ArxivPaperWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.ArxivPaperUpdateToOneWithWhereWithoutSemanticScholarPaperInput, Prisma.ArxivPaperUpdateWithoutSemanticScholarPaperInput>, Prisma.ArxivPaperUncheckedUpdateWithoutSemanticScholarPaperInput>
}

export type ArxivPaperCreateWithoutAuthorsInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  categories?: Prisma.ArxivCategoryCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceCreateNestedManyWithoutPaperInput
  citedBy?: Prisma.ReferenceCreateNestedManyWithoutReferenceInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperUncheckedCreateWithoutAuthorsInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  categories?: Prisma.ArxivCategoryUncheckedCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceUncheckedCreateNestedManyWithoutPaperInput
  citedBy?: Prisma.ReferenceUncheckedCreateNestedManyWithoutReferenceInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperCreateOrConnectWithoutAuthorsInput = {
  where: Prisma.ArxivPaperWhereUniqueInput
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutAuthorsInput, Prisma.ArxivPaperUncheckedCreateWithoutAuthorsInput>
}

export type ArxivPaperUpsertWithoutAuthorsInput = {
  update: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutAuthorsInput, Prisma.ArxivPaperUncheckedUpdateWithoutAuthorsInput>
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutAuthorsInput, Prisma.ArxivPaperUncheckedCreateWithoutAuthorsInput>
  where?: Prisma.ArxivPaperWhereInput
}

export type ArxivPaperUpdateToOneWithWhereWithoutAuthorsInput = {
  where?: Prisma.ArxivPaperWhereInput
  data: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutAuthorsInput, Prisma.ArxivPaperUncheckedUpdateWithoutAuthorsInput>
}

export type ArxivPaperUpdateWithoutAuthorsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  categories?: Prisma.ArxivCategoryUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUpdateManyWithoutPaperNestedInput
  citedBy?: Prisma.ReferenceUpdateManyWithoutReferenceNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperUncheckedUpdateWithoutAuthorsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  categories?: Prisma.ArxivCategoryUncheckedUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUncheckedUpdateManyWithoutPaperNestedInput
  citedBy?: Prisma.ReferenceUncheckedUpdateManyWithoutReferenceNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperCreateWithoutCategoriesInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceCreateNestedManyWithoutPaperInput
  citedBy?: Prisma.ReferenceCreateNestedManyWithoutReferenceInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperUncheckedCreateWithoutCategoriesInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceUncheckedCreateNestedManyWithoutPaperInput
  citedBy?: Prisma.ReferenceUncheckedCreateNestedManyWithoutReferenceInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperCreateOrConnectWithoutCategoriesInput = {
  where: Prisma.ArxivPaperWhereUniqueInput
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutCategoriesInput, Prisma.ArxivPaperUncheckedCreateWithoutCategoriesInput>
}

export type ArxivPaperUpsertWithoutCategoriesInput = {
  update: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutCategoriesInput, Prisma.ArxivPaperUncheckedUpdateWithoutCategoriesInput>
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutCategoriesInput, Prisma.ArxivPaperUncheckedCreateWithoutCategoriesInput>
  where?: Prisma.ArxivPaperWhereInput
}

export type ArxivPaperUpdateToOneWithWhereWithoutCategoriesInput = {
  where?: Prisma.ArxivPaperWhereInput
  data: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutCategoriesInput, Prisma.ArxivPaperUncheckedUpdateWithoutCategoriesInput>
}

export type ArxivPaperUpdateWithoutCategoriesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUpdateManyWithoutPaperNestedInput
  citedBy?: Prisma.ReferenceUpdateManyWithoutReferenceNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperUncheckedUpdateWithoutCategoriesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUncheckedUpdateManyWithoutPaperNestedInput
  citedBy?: Prisma.ReferenceUncheckedUpdateManyWithoutReferenceNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperCreateWithoutReferencesInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameCreateNestedManyWithoutArxivPaperInput
  categories?: Prisma.ArxivCategoryCreateNestedManyWithoutArxivPaperInput
  citedBy?: Prisma.ReferenceCreateNestedManyWithoutReferenceInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperUncheckedCreateWithoutReferencesInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedCreateNestedManyWithoutArxivPaperInput
  categories?: Prisma.ArxivCategoryUncheckedCreateNestedManyWithoutArxivPaperInput
  citedBy?: Prisma.ReferenceUncheckedCreateNestedManyWithoutReferenceInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperCreateOrConnectWithoutReferencesInput = {
  where: Prisma.ArxivPaperWhereUniqueInput
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutReferencesInput, Prisma.ArxivPaperUncheckedCreateWithoutReferencesInput>
}

export type ArxivPaperCreateWithoutCitedByInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameCreateNestedManyWithoutArxivPaperInput
  categories?: Prisma.ArxivCategoryCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceCreateNestedManyWithoutPaperInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperUncheckedCreateWithoutCitedByInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedCreateNestedManyWithoutArxivPaperInput
  categories?: Prisma.ArxivCategoryUncheckedCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceUncheckedCreateNestedManyWithoutPaperInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedCreateNestedOneWithoutArxivPaperInput
}

export type ArxivPaperCreateOrConnectWithoutCitedByInput = {
  where: Prisma.ArxivPaperWhereUniqueInput
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutCitedByInput, Prisma.ArxivPaperUncheckedCreateWithoutCitedByInput>
}

export type ArxivPaperUpsertWithoutReferencesInput = {
  update: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutReferencesInput, Prisma.ArxivPaperUncheckedUpdateWithoutReferencesInput>
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutReferencesInput, Prisma.ArxivPaperUncheckedCreateWithoutReferencesInput>
  where?: Prisma.ArxivPaperWhereInput
}

export type ArxivPaperUpdateToOneWithWhereWithoutReferencesInput = {
  where?: Prisma.ArxivPaperWhereInput
  data: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutReferencesInput, Prisma.ArxivPaperUncheckedUpdateWithoutReferencesInput>
}

export type ArxivPaperUpdateWithoutReferencesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUpdateManyWithoutArxivPaperNestedInput
  categories?: Prisma.ArxivCategoryUpdateManyWithoutArxivPaperNestedInput
  citedBy?: Prisma.ReferenceUpdateManyWithoutReferenceNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperUncheckedUpdateWithoutReferencesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedUpdateManyWithoutArxivPaperNestedInput
  categories?: Prisma.ArxivCategoryUncheckedUpdateManyWithoutArxivPaperNestedInput
  citedBy?: Prisma.ReferenceUncheckedUpdateManyWithoutReferenceNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperUpsertWithoutCitedByInput = {
  update: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutCitedByInput, Prisma.ArxivPaperUncheckedUpdateWithoutCitedByInput>
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutCitedByInput, Prisma.ArxivPaperUncheckedCreateWithoutCitedByInput>
  where?: Prisma.ArxivPaperWhereInput
}

export type ArxivPaperUpdateToOneWithWhereWithoutCitedByInput = {
  where?: Prisma.ArxivPaperWhereInput
  data: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutCitedByInput, Prisma.ArxivPaperUncheckedUpdateWithoutCitedByInput>
}

export type ArxivPaperUpdateWithoutCitedByInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUpdateManyWithoutArxivPaperNestedInput
  categories?: Prisma.ArxivCategoryUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUpdateManyWithoutPaperNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperUncheckedUpdateWithoutCitedByInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedUpdateManyWithoutArxivPaperNestedInput
  categories?: Prisma.ArxivCategoryUncheckedUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUncheckedUpdateManyWithoutPaperNestedInput
  semanticScholarPaper?: Prisma.SemanticScholarPaperUncheckedUpdateOneWithoutArxivPaperNestedInput
}

export type ArxivPaperCreateWithoutSemanticScholarPaperInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameCreateNestedManyWithoutArxivPaperInput
  categories?: Prisma.ArxivCategoryCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceCreateNestedManyWithoutPaperInput
  citedBy?: Prisma.ReferenceCreateNestedManyWithoutReferenceInput
}

export type ArxivPaperUncheckedCreateWithoutSemanticScholarPaperInput = {
  id?: string
  arxivId: string
  arxivUrl: string
  title?: string | null
  abstract?: string | null
  publishedDate?: string | null
  primaryCategory?: string | null
  license?: string | null
  updatedAtArxiv?: string | null
  comment?: string | null
  journalRef?: string | null
  doi?: string | null
  status?: string
  processedAt?: Date | string | null
  referencesFetched?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedCreateNestedManyWithoutArxivPaperInput
  categories?: Prisma.ArxivCategoryUncheckedCreateNestedManyWithoutArxivPaperInput
  references?: Prisma.ReferenceUncheckedCreateNestedManyWithoutPaperInput
  citedBy?: Prisma.ReferenceUncheckedCreateNestedManyWithoutReferenceInput
}

export type ArxivPaperCreateOrConnectWithoutSemanticScholarPaperInput = {
  where: Prisma.ArxivPaperWhereUniqueInput
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutSemanticScholarPaperInput, Prisma.ArxivPaperUncheckedCreateWithoutSemanticScholarPaperInput>
}

export type ArxivPaperUpsertWithoutSemanticScholarPaperInput = {
  update: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutSemanticScholarPaperInput, Prisma.ArxivPaperUncheckedUpdateWithoutSemanticScholarPaperInput>
  create: Prisma.XOR<Prisma.ArxivPaperCreateWithoutSemanticScholarPaperInput, Prisma.ArxivPaperUncheckedCreateWithoutSemanticScholarPaperInput>
  where?: Prisma.ArxivPaperWhereInput
}

export type ArxivPaperUpdateToOneWithWhereWithoutSemanticScholarPaperInput = {
  where?: Prisma.ArxivPaperWhereInput
  data: Prisma.XOR<Prisma.ArxivPaperUpdateWithoutSemanticScholarPaperInput, Prisma.ArxivPaperUncheckedUpdateWithoutSemanticScholarPaperInput>
}

export type ArxivPaperUpdateWithoutSemanticScholarPaperInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUpdateManyWithoutArxivPaperNestedInput
  categories?: Prisma.ArxivCategoryUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUpdateManyWithoutPaperNestedInput
  citedBy?: Prisma.ReferenceUpdateManyWithoutReferenceNestedInput
}

export type ArxivPaperUncheckedUpdateWithoutSemanticScholarPaperInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  arxivId?: Prisma.StringFieldUpdateOperationsInput | string
  arxivUrl?: Prisma.StringFieldUpdateOperationsInput | string
  title?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  abstract?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  publishedDate?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  primaryCategory?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  license?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  updatedAtArxiv?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  comment?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  journalRef?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  doi?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.StringFieldUpdateOperationsInput | string
  processedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  referencesFetched?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  authors?: Prisma.ArxivAuthorNameUncheckedUpdateManyWithoutArxivPaperNestedInput
  categories?: Prisma.ArxivCategoryUncheckedUpdateManyWithoutArxivPaperNestedInput
  references?: Prisma.ReferenceUncheckedUpdateManyWithoutPaperNestedInput
  citedBy?: Prisma.ReferenceUncheckedUpdateManyWithoutReferenceNestedInput
}


/**
 * Count Type ArxivPaperCountOutputType
 */

export type ArxivPaperCountOutputType = {
  authors: number
  categories: number
  references: number
  citedBy: number
}

export type ArxivPaperCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  authors?: boolean | ArxivPaperCountOutputTypeCountAuthorsArgs
  categories?: boolean | ArxivPaperCountOutputTypeCountCategoriesArgs
  references?: boolean | ArxivPaperCountOutputTypeCountReferencesArgs
  citedBy?: boolean | ArxivPaperCountOutputTypeCountCitedByArgs
}

/**
 * ArxivPaperCountOutputType without action
 */
export type ArxivPaperCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaperCountOutputType
   */
  select?: Prisma.ArxivPaperCountOutputTypeSelect<ExtArgs> | null
}

/**
 * ArxivPaperCountOutputType without action
 */
export type ArxivPaperCountOutputTypeCountAuthorsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ArxivAuthorNameWhereInput
}

/**
 * ArxivPaperCountOutputType without action
 */
export type ArxivPaperCountOutputTypeCountCategoriesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ArxivCategoryWhereInput
}

/**
 * ArxivPaperCountOutputType without action
 */
export type ArxivPaperCountOutputTypeCountReferencesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ReferenceWhereInput
}

/**
 * ArxivPaperCountOutputType without action
 */
export type ArxivPaperCountOutputTypeCountCitedByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ReferenceWhereInput
}


export type ArxivPaperSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  arxivId?: boolean
  arxivUrl?: boolean
  title?: boolean
  abstract?: boolean
  publishedDate?: boolean
  primaryCategory?: boolean
  license?: boolean
  updatedAtArxiv?: boolean
  comment?: boolean
  journalRef?: boolean
  doi?: boolean
  status?: boolean
  processedAt?: boolean
  referencesFetched?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  authors?: boolean | Prisma.ArxivPaper$authorsArgs<ExtArgs>
  categories?: boolean | Prisma.ArxivPaper$categoriesArgs<ExtArgs>
  references?: boolean | Prisma.ArxivPaper$referencesArgs<ExtArgs>
  citedBy?: boolean | Prisma.ArxivPaper$citedByArgs<ExtArgs>
  semanticScholarPaper?: boolean | Prisma.ArxivPaper$semanticScholarPaperArgs<ExtArgs>
  _count?: boolean | Prisma.ArxivPaperCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["arxivPaper"]>

export type ArxivPaperSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  arxivId?: boolean
  arxivUrl?: boolean
  title?: boolean
  abstract?: boolean
  publishedDate?: boolean
  primaryCategory?: boolean
  license?: boolean
  updatedAtArxiv?: boolean
  comment?: boolean
  journalRef?: boolean
  doi?: boolean
  status?: boolean
  processedAt?: boolean
  referencesFetched?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}, ExtArgs["result"]["arxivPaper"]>

export type ArxivPaperSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  arxivId?: boolean
  arxivUrl?: boolean
  title?: boolean
  abstract?: boolean
  publishedDate?: boolean
  primaryCategory?: boolean
  license?: boolean
  updatedAtArxiv?: boolean
  comment?: boolean
  journalRef?: boolean
  doi?: boolean
  status?: boolean
  processedAt?: boolean
  referencesFetched?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}, ExtArgs["result"]["arxivPaper"]>

export type ArxivPaperSelectScalar = {
  id?: boolean
  arxivId?: boolean
  arxivUrl?: boolean
  title?: boolean
  abstract?: boolean
  publishedDate?: boolean
  primaryCategory?: boolean
  license?: boolean
  updatedAtArxiv?: boolean
  comment?: boolean
  journalRef?: boolean
  doi?: boolean
  status?: boolean
  processedAt?: boolean
  referencesFetched?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type ArxivPaperOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "arxivId" | "arxivUrl" | "title" | "abstract" | "publishedDate" | "primaryCategory" | "license" | "updatedAtArxiv" | "comment" | "journalRef" | "doi" | "status" | "processedAt" | "referencesFetched" | "createdAt" | "updatedAt", ExtArgs["result"]["arxivPaper"]>
export type ArxivPaperInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  authors?: boolean | Prisma.ArxivPaper$authorsArgs<ExtArgs>
  categories?: boolean | Prisma.ArxivPaper$categoriesArgs<ExtArgs>
  references?: boolean | Prisma.ArxivPaper$referencesArgs<ExtArgs>
  citedBy?: boolean | Prisma.ArxivPaper$citedByArgs<ExtArgs>
  semanticScholarPaper?: boolean | Prisma.ArxivPaper$semanticScholarPaperArgs<ExtArgs>
  _count?: boolean | Prisma.ArxivPaperCountOutputTypeDefaultArgs<ExtArgs>
}
export type ArxivPaperIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}
export type ArxivPaperIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $ArxivPaperPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ArxivPaper"
  objects: {
    authors: Prisma.$ArxivAuthorNamePayload<ExtArgs>[]
    categories: Prisma.$ArxivCategoryPayload<ExtArgs>[]
    references: Prisma.$ReferencePayload<ExtArgs>[]
    citedBy: Prisma.$ReferencePayload<ExtArgs>[]
    semanticScholarPaper: Prisma.$SemanticScholarPaperPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    arxivId: string
    arxivUrl: string
    title: string | null
    abstract: string | null
    publishedDate: string | null
    primaryCategory: string | null
    license: string | null
    updatedAtArxiv: string | null
    comment: string | null
    journalRef: string | null
    doi: string | null
    status: string
    processedAt: Date | null
    referencesFetched: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["arxivPaper"]>
  composites: {}
}

export type ArxivPaperGetPayload<S extends boolean | null | undefined | ArxivPaperDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload, S>

export type ArxivPaperCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ArxivPaperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ArxivPaperCountAggregateInputType | true
  }

export interface ArxivPaperDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArxivPaper'], meta: { name: 'ArxivPaper' } }
  /**
   * Find zero or one ArxivPaper that matches the filter.
   * @param {ArxivPaperFindUniqueArgs} args - Arguments to find a ArxivPaper
   * @example
   * // Get one ArxivPaper
   * const arxivPaper = await prisma.arxivPaper.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ArxivPaperFindUniqueArgs>(args: Prisma.SelectSubset<T, ArxivPaperFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ArxivPaperClient<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ArxivPaper that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ArxivPaperFindUniqueOrThrowArgs} args - Arguments to find a ArxivPaper
   * @example
   * // Get one ArxivPaper
   * const arxivPaper = await prisma.arxivPaper.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ArxivPaperFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ArxivPaperFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ArxivPaperClient<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ArxivPaper that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ArxivPaperFindFirstArgs} args - Arguments to find a ArxivPaper
   * @example
   * // Get one ArxivPaper
   * const arxivPaper = await prisma.arxivPaper.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ArxivPaperFindFirstArgs>(args?: Prisma.SelectSubset<T, ArxivPaperFindFirstArgs<ExtArgs>>): Prisma.Prisma__ArxivPaperClient<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ArxivPaper that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ArxivPaperFindFirstOrThrowArgs} args - Arguments to find a ArxivPaper
   * @example
   * // Get one ArxivPaper
   * const arxivPaper = await prisma.arxivPaper.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ArxivPaperFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ArxivPaperFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ArxivPaperClient<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ArxivPapers that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ArxivPaperFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ArxivPapers
   * const arxivPapers = await prisma.arxivPaper.findMany()
   * 
   * // Get first 10 ArxivPapers
   * const arxivPapers = await prisma.arxivPaper.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const arxivPaperWithIdOnly = await prisma.arxivPaper.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ArxivPaperFindManyArgs>(args?: Prisma.SelectSubset<T, ArxivPaperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ArxivPaper.
   * @param {ArxivPaperCreateArgs} args - Arguments to create a ArxivPaper.
   * @example
   * // Create one ArxivPaper
   * const ArxivPaper = await prisma.arxivPaper.create({
   *   data: {
   *     // ... data to create a ArxivPaper
   *   }
   * })
   * 
   */
  create<T extends ArxivPaperCreateArgs>(args: Prisma.SelectSubset<T, ArxivPaperCreateArgs<ExtArgs>>): Prisma.Prisma__ArxivPaperClient<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ArxivPapers.
   * @param {ArxivPaperCreateManyArgs} args - Arguments to create many ArxivPapers.
   * @example
   * // Create many ArxivPapers
   * const arxivPaper = await prisma.arxivPaper.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ArxivPaperCreateManyArgs>(args?: Prisma.SelectSubset<T, ArxivPaperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ArxivPapers and returns the data saved in the database.
   * @param {ArxivPaperCreateManyAndReturnArgs} args - Arguments to create many ArxivPapers.
   * @example
   * // Create many ArxivPapers
   * const arxivPaper = await prisma.arxivPaper.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ArxivPapers and only return the `id`
   * const arxivPaperWithIdOnly = await prisma.arxivPaper.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ArxivPaperCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ArxivPaperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ArxivPaper.
   * @param {ArxivPaperDeleteArgs} args - Arguments to delete one ArxivPaper.
   * @example
   * // Delete one ArxivPaper
   * const ArxivPaper = await prisma.arxivPaper.delete({
   *   where: {
   *     // ... filter to delete one ArxivPaper
   *   }
   * })
   * 
   */
  delete<T extends ArxivPaperDeleteArgs>(args: Prisma.SelectSubset<T, ArxivPaperDeleteArgs<ExtArgs>>): Prisma.Prisma__ArxivPaperClient<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ArxivPaper.
   * @param {ArxivPaperUpdateArgs} args - Arguments to update one ArxivPaper.
   * @example
   * // Update one ArxivPaper
   * const arxivPaper = await prisma.arxivPaper.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ArxivPaperUpdateArgs>(args: Prisma.SelectSubset<T, ArxivPaperUpdateArgs<ExtArgs>>): Prisma.Prisma__ArxivPaperClient<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ArxivPapers.
   * @param {ArxivPaperDeleteManyArgs} args - Arguments to filter ArxivPapers to delete.
   * @example
   * // Delete a few ArxivPapers
   * const { count } = await prisma.arxivPaper.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ArxivPaperDeleteManyArgs>(args?: Prisma.SelectSubset<T, ArxivPaperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ArxivPapers.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ArxivPaperUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ArxivPapers
   * const arxivPaper = await prisma.arxivPaper.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ArxivPaperUpdateManyArgs>(args: Prisma.SelectSubset<T, ArxivPaperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ArxivPapers and returns the data updated in the database.
   * @param {ArxivPaperUpdateManyAndReturnArgs} args - Arguments to update many ArxivPapers.
   * @example
   * // Update many ArxivPapers
   * const arxivPaper = await prisma.arxivPaper.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ArxivPapers and only return the `id`
   * const arxivPaperWithIdOnly = await prisma.arxivPaper.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ArxivPaperUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ArxivPaperUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ArxivPaper.
   * @param {ArxivPaperUpsertArgs} args - Arguments to update or create a ArxivPaper.
   * @example
   * // Update or create a ArxivPaper
   * const arxivPaper = await prisma.arxivPaper.upsert({
   *   create: {
   *     // ... data to create a ArxivPaper
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ArxivPaper we want to update
   *   }
   * })
   */
  upsert<T extends ArxivPaperUpsertArgs>(args: Prisma.SelectSubset<T, ArxivPaperUpsertArgs<ExtArgs>>): Prisma.Prisma__ArxivPaperClient<runtime.Types.Result.GetResult<Prisma.$ArxivPaperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ArxivPapers.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ArxivPaperCountArgs} args - Arguments to filter ArxivPapers to count.
   * @example
   * // Count the number of ArxivPapers
   * const count = await prisma.arxivPaper.count({
   *   where: {
   *     // ... the filter for the ArxivPapers we want to count
   *   }
   * })
  **/
  count<T extends ArxivPaperCountArgs>(
    args?: Prisma.Subset<T, ArxivPaperCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ArxivPaperCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ArxivPaper.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ArxivPaperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ArxivPaperAggregateArgs>(args: Prisma.Subset<T, ArxivPaperAggregateArgs>): Prisma.PrismaPromise<GetArxivPaperAggregateType<T>>

  /**
   * Group by ArxivPaper.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ArxivPaperGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ArxivPaperGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ArxivPaperGroupByArgs['orderBy'] }
      : { orderBy?: ArxivPaperGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ArxivPaperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArxivPaperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ArxivPaper model
 */
readonly fields: ArxivPaperFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ArxivPaper.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ArxivPaperClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  authors<T extends Prisma.ArxivPaper$authorsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ArxivPaper$authorsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArxivAuthorNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  categories<T extends Prisma.ArxivPaper$categoriesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ArxivPaper$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ArxivCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  references<T extends Prisma.ArxivPaper$referencesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ArxivPaper$referencesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  citedBy<T extends Prisma.ArxivPaper$citedByArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ArxivPaper$citedByArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  semanticScholarPaper<T extends Prisma.ArxivPaper$semanticScholarPaperArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ArxivPaper$semanticScholarPaperArgs<ExtArgs>>): Prisma.Prisma__SemanticScholarPaperClient<runtime.Types.Result.GetResult<Prisma.$SemanticScholarPaperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ArxivPaper model
 */
export interface ArxivPaperFieldRefs {
  readonly id: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly arxivId: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly arxivUrl: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly title: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly abstract: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly publishedDate: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly primaryCategory: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly license: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly updatedAtArxiv: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly comment: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly journalRef: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly doi: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly status: Prisma.FieldRef<"ArxivPaper", 'String'>
  readonly processedAt: Prisma.FieldRef<"ArxivPaper", 'DateTime'>
  readonly referencesFetched: Prisma.FieldRef<"ArxivPaper", 'Boolean'>
  readonly createdAt: Prisma.FieldRef<"ArxivPaper", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"ArxivPaper", 'DateTime'>
}
    

// Custom InputTypes
/**
 * ArxivPaper findUnique
 */
export type ArxivPaperFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * Filter, which ArxivPaper to fetch.
   */
  where: Prisma.ArxivPaperWhereUniqueInput
}

/**
 * ArxivPaper findUniqueOrThrow
 */
export type ArxivPaperFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * Filter, which ArxivPaper to fetch.
   */
  where: Prisma.ArxivPaperWhereUniqueInput
}

/**
 * ArxivPaper findFirst
 */
export type ArxivPaperFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * Filter, which ArxivPaper to fetch.
   */
  where?: Prisma.ArxivPaperWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ArxivPapers to fetch.
   */
  orderBy?: Prisma.ArxivPaperOrderByWithRelationInput | Prisma.ArxivPaperOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ArxivPapers.
   */
  cursor?: Prisma.ArxivPaperWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ArxivPapers from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ArxivPapers.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ArxivPapers.
   */
  distinct?: Prisma.ArxivPaperScalarFieldEnum | Prisma.ArxivPaperScalarFieldEnum[]
}

/**
 * ArxivPaper findFirstOrThrow
 */
export type ArxivPaperFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * Filter, which ArxivPaper to fetch.
   */
  where?: Prisma.ArxivPaperWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ArxivPapers to fetch.
   */
  orderBy?: Prisma.ArxivPaperOrderByWithRelationInput | Prisma.ArxivPaperOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ArxivPapers.
   */
  cursor?: Prisma.ArxivPaperWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ArxivPapers from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ArxivPapers.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ArxivPapers.
   */
  distinct?: Prisma.ArxivPaperScalarFieldEnum | Prisma.ArxivPaperScalarFieldEnum[]
}

/**
 * ArxivPaper findMany
 */
export type ArxivPaperFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * Filter, which ArxivPapers to fetch.
   */
  where?: Prisma.ArxivPaperWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ArxivPapers to fetch.
   */
  orderBy?: Prisma.ArxivPaperOrderByWithRelationInput | Prisma.ArxivPaperOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ArxivPapers.
   */
  cursor?: Prisma.ArxivPaperWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ArxivPapers from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ArxivPapers.
   */
  skip?: number
  distinct?: Prisma.ArxivPaperScalarFieldEnum | Prisma.ArxivPaperScalarFieldEnum[]
}

/**
 * ArxivPaper create
 */
export type ArxivPaperCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * The data needed to create a ArxivPaper.
   */
  data: Prisma.XOR<Prisma.ArxivPaperCreateInput, Prisma.ArxivPaperUncheckedCreateInput>
}

/**
 * ArxivPaper createMany
 */
export type ArxivPaperCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ArxivPapers.
   */
  data: Prisma.ArxivPaperCreateManyInput | Prisma.ArxivPaperCreateManyInput[]
}

/**
 * ArxivPaper createManyAndReturn
 */
export type ArxivPaperCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * The data used to create many ArxivPapers.
   */
  data: Prisma.ArxivPaperCreateManyInput | Prisma.ArxivPaperCreateManyInput[]
}

/**
 * ArxivPaper update
 */
export type ArxivPaperUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * The data needed to update a ArxivPaper.
   */
  data: Prisma.XOR<Prisma.ArxivPaperUpdateInput, Prisma.ArxivPaperUncheckedUpdateInput>
  /**
   * Choose, which ArxivPaper to update.
   */
  where: Prisma.ArxivPaperWhereUniqueInput
}

/**
 * ArxivPaper updateMany
 */
export type ArxivPaperUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ArxivPapers.
   */
  data: Prisma.XOR<Prisma.ArxivPaperUpdateManyMutationInput, Prisma.ArxivPaperUncheckedUpdateManyInput>
  /**
   * Filter which ArxivPapers to update
   */
  where?: Prisma.ArxivPaperWhereInput
  /**
   * Limit how many ArxivPapers to update.
   */
  limit?: number
}

/**
 * ArxivPaper updateManyAndReturn
 */
export type ArxivPaperUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * The data used to update ArxivPapers.
   */
  data: Prisma.XOR<Prisma.ArxivPaperUpdateManyMutationInput, Prisma.ArxivPaperUncheckedUpdateManyInput>
  /**
   * Filter which ArxivPapers to update
   */
  where?: Prisma.ArxivPaperWhereInput
  /**
   * Limit how many ArxivPapers to update.
   */
  limit?: number
}

/**
 * ArxivPaper upsert
 */
export type ArxivPaperUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * The filter to search for the ArxivPaper to update in case it exists.
   */
  where: Prisma.ArxivPaperWhereUniqueInput
  /**
   * In case the ArxivPaper found by the `where` argument doesn't exist, create a new ArxivPaper with this data.
   */
  create: Prisma.XOR<Prisma.ArxivPaperCreateInput, Prisma.ArxivPaperUncheckedCreateInput>
  /**
   * In case the ArxivPaper was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ArxivPaperUpdateInput, Prisma.ArxivPaperUncheckedUpdateInput>
}

/**
 * ArxivPaper delete
 */
export type ArxivPaperDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
  /**
   * Filter which ArxivPaper to delete.
   */
  where: Prisma.ArxivPaperWhereUniqueInput
}

/**
 * ArxivPaper deleteMany
 */
export type ArxivPaperDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ArxivPapers to delete
   */
  where?: Prisma.ArxivPaperWhereInput
  /**
   * Limit how many ArxivPapers to delete.
   */
  limit?: number
}

/**
 * ArxivPaper.authors
 */
export type ArxivPaper$authorsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivAuthorName
   */
  select?: Prisma.ArxivAuthorNameSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivAuthorName
   */
  omit?: Prisma.ArxivAuthorNameOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivAuthorNameInclude<ExtArgs> | null
  where?: Prisma.ArxivAuthorNameWhereInput
  orderBy?: Prisma.ArxivAuthorNameOrderByWithRelationInput | Prisma.ArxivAuthorNameOrderByWithRelationInput[]
  cursor?: Prisma.ArxivAuthorNameWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.ArxivAuthorNameScalarFieldEnum | Prisma.ArxivAuthorNameScalarFieldEnum[]
}

/**
 * ArxivPaper.categories
 */
export type ArxivPaper$categoriesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivCategory
   */
  select?: Prisma.ArxivCategorySelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivCategory
   */
  omit?: Prisma.ArxivCategoryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivCategoryInclude<ExtArgs> | null
  where?: Prisma.ArxivCategoryWhereInput
  orderBy?: Prisma.ArxivCategoryOrderByWithRelationInput | Prisma.ArxivCategoryOrderByWithRelationInput[]
  cursor?: Prisma.ArxivCategoryWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.ArxivCategoryScalarFieldEnum | Prisma.ArxivCategoryScalarFieldEnum[]
}

/**
 * ArxivPaper.references
 */
export type ArxivPaper$referencesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Reference
   */
  select?: Prisma.ReferenceSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Reference
   */
  omit?: Prisma.ReferenceOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReferenceInclude<ExtArgs> | null
  where?: Prisma.ReferenceWhereInput
  orderBy?: Prisma.ReferenceOrderByWithRelationInput | Prisma.ReferenceOrderByWithRelationInput[]
  cursor?: Prisma.ReferenceWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.ReferenceScalarFieldEnum | Prisma.ReferenceScalarFieldEnum[]
}

/**
 * ArxivPaper.citedBy
 */
export type ArxivPaper$citedByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Reference
   */
  select?: Prisma.ReferenceSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Reference
   */
  omit?: Prisma.ReferenceOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ReferenceInclude<ExtArgs> | null
  where?: Prisma.ReferenceWhereInput
  orderBy?: Prisma.ReferenceOrderByWithRelationInput | Prisma.ReferenceOrderByWithRelationInput[]
  cursor?: Prisma.ReferenceWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.ReferenceScalarFieldEnum | Prisma.ReferenceScalarFieldEnum[]
}

/**
 * ArxivPaper.semanticScholarPaper
 */
export type ArxivPaper$semanticScholarPaperArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SemanticScholarPaper
   */
  select?: Prisma.SemanticScholarPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SemanticScholarPaper
   */
  omit?: Prisma.SemanticScholarPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SemanticScholarPaperInclude<ExtArgs> | null
  where?: Prisma.SemanticScholarPaperWhereInput
}

/**
 * ArxivPaper without action
 */
export type ArxivPaperDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ArxivPaper
   */
  select?: Prisma.ArxivPaperSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ArxivPaper
   */
  omit?: Prisma.ArxivPaperOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ArxivPaperInclude<ExtArgs> | null
}
